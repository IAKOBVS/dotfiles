#!/usr/bin/perl
use strict;
use warnings;
use diagnostics;

my @old;
my @new;

my $new;

foreach my $old (glob('./*')) {
	no warnings; # ignores use of \1 over $1 warning for backreference
	$new = $old;

	$new =~ s/\[[^\]]*\]//g; # rm [.*]

	# remove leading
	$new =~ s/^\.\/[[:space:]]*([^[:space:]])/\1/; # ./  file.mkv -> ./file.mkv

	# remove (str)
	$new =~ s/\([[:digit:]]*\)//g; # remove (2019)
	$new =~ s/\([^\)]*1080[^\)]*\)//g; # remove (.*1080.*)

	# remove trailing before .ext
	$new =~ s/[[:space:]]*(\.[[:alnum:]]*)$/\1/; #  .mkv -> .mkv
	$new =~ s/-*(\.[[:alnum:]]*)$/\1/; # _.mkv -> .mkv
	$new =~ s/_*(\.[[:alnum:]]*)$/\1/; # -.mkv -> .mkv

	# remove trailing
	$new =~ s/\ *$//; # space
	$new =~ s/_*$//; # _
	$new =~ s/-*$//; # -

	# remove weird symbols
	$new =~ s/__/_/g; # __ -> _
	$new =~ s/\ \ /\ /g; # two spaces -> _
	$new =~ s/--/-/g; # -- -> -
	$new =~ s/_-_/_/g; # _-_ -> _
	$new =~ s/\.-/_/g; # .- -> _

	$new =~ s/eason\([[:digit:]]\)/eason\ \1/g; # season2 -> season 2

	print "$new\n";
	push @old, $old;
	push @new, $new;
}

print "\nDo you want to rename the files? (y/n)\n";
my $in = readline(STDIN);
chomp($in);

if ($in eq 'y' || $in eq 'Y') {
	for my $i (0..$#old) {
		rename($old[$i], $new[$i]) or print "Unable to rename $old[$i] to $new[$i]\n";
	}
	print "Files successfully renamed!\n";
}
