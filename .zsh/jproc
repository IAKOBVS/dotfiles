#!/bin/sh

# SPDX-License-Identifier: MIT */
# Copyright (c) 2026 James Tirta Halim <tirtajames45 at gmail dot com>
# This file is part of IAKOBVS/dotfiles.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# This file is used for doing inter-process communication, using tmp files,
# between vim, grep, and lf, and can be easily extended for other programs.
#
# The motivation is to be able to call cli commands within the current program,
# and directly transition into the next program, without needing to exit into the
# terminal, emulating the behaviour of plugins such as fzf.vim with a shell script
# that can be used for other programs, and adheres more to the UNIX philosophy.
#
# For every opened shell, it will save the last directory and command in
# a temporary file, whose value will be read in the future to determine
# which command to execute and directory into which to cd.
#
# The tmp files will be temporarily cleaned up by jproc-cleanup by checking
# if the PIDs, which are embedded into the file name, exist, removing the
# tmp files whose PIDs do not.

# Available CPU cores.
export JPROC_NPROC=$(nproc 2$JPROC_REDIRECT_STDOUT || sysctl -n hw.logicalcpu 2$JPROC_REDIRECT_STDOUT || getconf _NPROCESSORS_ONLN 2$JPROC_REDIRECT_STDOUT)

# Default args for rg.
JPROC_RG_ARGS="-j $JPROC_NPROC --color=always --no-heading -n --max-filesize 1M"

# Temporary files here will be cleaned up periodically by jproc-cleanup.
export JPROC_DIR=/tmp/jproc-private
export JPROC_DIR_PID=$JPROC_DIR/$$

# Template for tmp files
export JPROC_VIM_PROG=$JPROC_DIR_PID/vim_prog
export JPROC_VIM_ARG=$JPROC_DIR_PID/vim_arg
export JPROC_VIM_FILE_LAST=$JPROC_DIR_PID/vim_file_last
export JPROC_LF_DIR=$JPROC_DIR_PID/lf_dir
export JPROC_CMD_LAST=$JPROC_DIR_PID/cmd_last

# TODO: maybe make a more human readable format like
# /proc/ since performance doesn't matter here

# Export the commands to support.
export JPROC_VIMCD=1
export JPROC_LFCD=2
export JPROC_FZF=3
export JPROC_FZFLIVE=4
export JPROC_FZFLIVEHOME=5
export JPROC_GREPVIM=6

# Initialize tmp file.
/bin/mkdir -p $JPROC_DIR
/bin/mkdir -p $JPROC_DIR_PID
echo >$JPROC_VIM_PROG
echo >$JPROC_VIM_ARG
echo >$JPROC_LF_DIR
echo >$JPROC_VIM_FILE_LAST
echo >$JPROC_CMD_LAST

JPROC_REDIRECT_STDOUT=''
JPROC_REDIRECT_STDERR=''
# JPROC_REDIRECT_STDOUT='>/dev/null'
# JPROC_REDIRECT_STDERR='2>/dev/null'

touch()
{
	file=$(realpath "$(echo $@ | awk '{print $NF}')" $JPROC_REDIRECT_STDERR)
	/bin/touch "$@"
}

mkdir()
{
	file=$(realpath "$(echo $@ | awk '{print $NF}')" $JPROC_REDIRECT_STDERR)
	/bin/mkdir "$@"
}

# Select program to call based on the value in the tmp file.
vim_sel()
{
	[ ! -f $JPROC_VIM_PROG ] $JPROC_REDIRECT_STDERR && return
	prog=$(cat $JPROC_VIM_PROG)
	if [ ! -f $JPROC_VIM_ARG ] $JPROC_REDIRECT_STDERR; then
		arg=''
	else
		arg=$(cat $JPROC_VIM_ARG)
	fi
	/bin/rm -f $JPROC_VIM_ARG $JPROC_VIM_PROG $JPROC_REDIRECT_STDOUT $JPROC_REDIRECT_STDERR
	case $prog in
	"$JPROC_VIMCD") vimcd "$arg" ;;
	"$JPROC_LFCD") lfcd "$arg" ;;
	"$JPROC_FZF") fzflive "$arg" ;;
	"$JPROC_FZFLIVE") fzflive "$arg" ;;
	"$JPROC_FZFLIVEHOME") fzflive "$arg" ;;
	"$JPROC_GREPVIM") grepvim "$arg" ;;
	esac
}

# Get the last command.
last_cmd()
{
	[ -f $JPROC_CMD_LAST ] || return
	case $(cat $JPROC_CMD_LAST) in
	"$JPROC_VIMCD") vimcd "$(cat $JPROC_VIM_FILE_LAST)" ;;
	"$JPROC_LFCD") lfcd "$(cat $JPROC_VIM_FILE_LAST)" ;;
	esac
}

# Open lf and cd to the last directory.
lfcd()
{
	echo >$JPROC_CMD_LAST
	dir=$(cat $JPROC_LF_DIR)
	lf -last-dir-path="$dir" "$@" $JPROC_REDIRECT_STDERR && vim_sel
	dir=$(cat $JPROC_LF_DIR)
	# (/bin/rm -f $JPROC_LF_DIR $JPROC_REDIRECT_STDOUT $JPROC_REDIRECT_STDERR &)
	[ -d "$dir" ] && [ "$dir" != "$(pwd)" ] && cd "$dir" || return
}

# Open vim and cd to the last directory.
vimcd()
{
	case $1 in
	'')
		cmd=$EDITOR
		file=
		;;
	'-c')
		file=$(realpath "$3")
		[ -f "$file" ] || return
		cd "$(dirname $file)" || return
		cmd=$EDITOR
		set -- -c "$2"
		;;
	*)
		file=$(realpath "$1")
		case $file in
		*.mkv | *.mov | *.mp4 | \
			*.png | *.jpg | *.jpeg)
			echo $JPROC_LFCD >$JPROC_CMD_LAST
			lfcd "$file"
			;;
		*)
			if [ -f "$file" ]; then
				cd "$(dirname $file)" || return
				cmd=$EDITOR
			elif [ -d "$file" ]; then
				cd "$file" || return
				cmd=lfcd
			else
				echo "$1 is not a file"
				echo 'touch file? (y/n)'
				read -r ok
				case $ok in
				y | Y) touch "$1" ;;
				*) return ;;
				esac
				cmd=$EDITOR
			fi
			shift
			;;
		esac
		;;
	esac
	echo $JPROC_VIMCD >$JPROC_CMD_LAST
	$cmd "$file" "$@" &&
		vim_sel
}

fzfbase()
{
	if [ ! "$1" ]; then
		last_cmd
	elif [ -f "$1" ]; then
		vimcd "$1"
	else
		lfcd "$1"
	fi
}

fzflive()
{
	# shellcheck disable=SC2164
	cd "$1" $JPROC_REDIRECT_STDERR
	fzfbase "$(find . -type f ! -path '*.git*' ! -path '*.o' ! -path '*node_modules*' | fzf --preview "bat --style=numbers --color=always {1}")"
}

# Grep and open vim.
grepvim()
{
	# shellcheck disable=SC2164
	cd "$1" $JPROC_REDIRECT_STDERR
	grepped=$(fzf -d: -n 2.. --bind "start:reload:rg $JPROC_RG_ARGS '' " \
		--bind "change:reload:rg $JPROC_RG_ARGS {q} || true" \
		--ansi --disabled \
		--preview-window 'down:20%:+{2}' \
		--preview 'bat --style=numbers --color=always --highlight-line {2} {1}')
	if [ "$grepped" ]; then
		vimcd -c ":$(echo "$grepped" | cut -d: -f2)" "${grepped%%:*}"
	else
		last_cmd
	fi
}
